require('dotenv').config();
const express = require('express');
const axios = require('axios');
const cors = require('cors');

const app = express();
app.use(cors());
app.use(express.json());

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
if (!GITHUB_TOKEN) throw new Error('‚ùå GITHUB_TOKEN not found in .env');

const github = axios.create({
  baseURL: 'https://api.github.com',
  headers: {
    Authorization: `Bearer ${GITHUB_TOKEN}`,
    Accept: 'application/vnd.github.v3+json',
    'User-Agent': 'GitHub-Analyzer-App'
  }
});

let apiCallCount = 0;

// Helper: Count API calls
function countAPICall(endpoint) {
  apiCallCount++;
  console.log(`üì° [GitHub API CALL #${apiCallCount}] ${endpoint}`);
}

// Helper: Fetch user info
async function fetchUserInfo(username) {
  const endpoint = `/users/${username}`;
  countAPICall(endpoint);

  try {
    const { data } = await github.get(endpoint);
    return {
      login: data.login,
      name: data.name,
      avatar_url: data.avatar_url,
      bio: data.bio,
      location: data.location,
      company: data.company,
      blog: data.blog,
      followers: data.followers,
      following: data.following,
      public_repos: data.public_repos,
      created_at: data.created_at,
      html_url: data.html_url
    };
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to fetch user info for ${username}`);
    return null;
  }
}

// Helper: Fetch repos
async function fetchRepos(username) {
  let repos = [];
  let page = 1;
  const perPage = 100;

  console.log(`üì• Fetching repositories for user: ${username}`);

  while (true) {
    const endpoint = `/users/${username}/repos?page=${page}&per_page=${perPage}`;
    countAPICall(endpoint);
    const { data } = await github.get(endpoint);

    repos.push(...data);
    if (data.length < perPage) break;
    page++;
  }

  console.log(`‚úÖ Fetched ${repos.length} repos`);
  return repos;
}

// Helper: Repo languages
async function fetchLanguages(username, repo) {
  const endpoint = `/repos/${username}/${repo}/languages`;
  countAPICall(endpoint);

  try {
    const { data } = await github.get(endpoint);
    return data;
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to fetch languages for ${repo}`);
    return {};
  }
}

// Helper: Count commits
async function fetchCommitCount(username, repo) {
  const endpoint = `/repos/${username}/${repo}/commits?per_page=1`;
  countAPICall(endpoint);

  try {
    const { headers, data } = await github.get(endpoint);

    const link = headers.link;
    if (link && link.includes('rel="last"')) {
      const match = link.match(/page=(\d+)>; rel="last"/);
      return match ? parseInt(match[1]) : 1;
    }

    return data.length;
  } catch {
    console.warn(`‚ö†Ô∏è Failed to fetch commits for ${repo}`);
    return 0;
  }
}

// Pattern analysis
function analyzePatterns(repos) {
  const yearly = {}, monthly = {};

  repos.forEach(repo => {
    const date = new Date(repo.created_at);
    const y = date.getFullYear();
    const m = `${y}-${String(date.getMonth() + 1).padStart(2, '0')}`;

    yearly[y] = (yearly[y] || 0) + 1;
    monthly[m] = (monthly[m] || 0) + 1;
  });

  return { yearly, monthly };
}

// Fun insights
function generateInsights(repos, langs, patterns) {
  const insights = [];

  insights.push(`üì¶ Total Repos: ${repos.length}`);
  insights.push(`üåê Languages Used: ${Object.keys(langs).length}`);

  const topLangEntry = Object.entries(langs).sort((a, b) => b[1] - a[1])[0];
  if (topLangEntry) {
    const [topLang, bytes] = topLangEntry;
    const linesApprox = Math.floor(bytes / 50); // crude approx lines from bytes
    insights.push(`üíª Top Language: ${topLang} (~${linesApprox.toLocaleString()} lines of code!)`);
  }

  const topYear = Object.entries(patterns.yearly).sort((a, b) => b[1] - a[1])[0];
  if (topYear) insights.push(`üî• Busiest Year: ${topYear[0]} (${topYear[1]} repos)`);

  const forked = repos.filter(r => r.fork).length;
  if (forked) insights.push(`üç¥ Forked Repos: ${forked}`);

  const totalStars = repos.reduce((sum, r) => sum + r.stargazers_count, 0);
  const avgStars = (totalStars / repos.length) || 0;
  if (avgStars > 10) {
    insights.push('üåü Star Power! Average stars per repo above 10 ‚Äî impressive popularity!');
  }

  const languageCount = Object.keys(langs).length;
  if (languageCount > 5) {
    insights.push('üåà Polyglot Developer! You code in over 5 languages ‚Äî versatile and adaptive.');
  }

  // Calculate days active between first and last repo created date
  if (repos.length > 1) {
    const firstDate = new Date(repos[0].created_at);
    const lastDate = new Date(repos[repos.length - 1].created_at);
    const activeDays = Math.floor((lastDate - firstDate) / (1000 * 60 * 60 * 24));
    if (activeDays > 1000) {
      insights.push('üèÖ Veteran Coder! You have been active for over 1000 days ‚Äî dedication is key.');
    }
  }

  const largestRepo = repos.reduce((max, r) => (r.size > max.size ? r : max), repos[0]);
  if (largestRepo && largestRepo.size > 1024 * 50) {
    insights.push(`üì¶ Big Project Alert! Your largest repo (${largestRepo.name}) is over 50 MB ‚Äî substantial work!`);
  }

  if (totalStars === 0) {
    insights.push('ü§´ Quiet Achiever ‚Äî stars don‚Äôt tell the whole story, keep rocking!');
  }

  return insights;
}

// üîç Main Analyzer Endpoint
app.post('/analyze/:username', async (req, res) => {
  const username = req.params.username;
  apiCallCount = 0; // Reset per request
  const startTime = Date.now();

  console.log(`\nüöÄ Starting analysis for: ${username}`);
  try {
    // Fetch user info and repos in parallel
    const [userInfo, repos] = await Promise.all([
      fetchUserInfo(username),
      fetchRepos(username)
    ]);

    if (!userInfo) {
      console.log('‚ö†Ô∏è User not found or failed to fetch user info');
      return res.status(404).json({ error: 'User not found or failed to fetch user info.' });
    }

    if (!repos.length) {
      console.log('‚ö†Ô∏è No repos found');
      return res.status(404).json({ error: 'No repositories found for this user.' });
    }

    const originals = repos.filter(r => !r.fork);
    const top20 = originals.slice(0, 20);

    console.log(`üîß Analyzing top ${top20.length} original repos`);

    const detailed = await Promise.all(top20.map(async repo => {
      const langs = await fetchLanguages(username, repo.name);
      const commits = await fetchCommitCount(username, repo.name);
      return {
        name: repo.name,
        stars: repo.stargazers_count,
        forks: repo.forks_count,
        commits,
        primaryLanguage: repo.language,
        sizeMB: (repo.size / 1024).toFixed(2),
        created: repo.created_at,
        updated: repo.updated_at,
        url: repo.html_url,
        languages: langs
      };
    }));

    const allLangs = {};
    detailed.forEach(repo => {
      for (const [lang, bytes] of Object.entries(repo.languages)) {
        allLangs[lang] = (allLangs[lang] || 0) + bytes;
      }
    });

    const patterns = analyzePatterns(repos);
    const insights = generateInsights(repos, allLangs, patterns);

    const duration = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(`‚úÖ Analysis complete in ${duration}s`);
    console.log(`üìä Total GitHub API calls: ${apiCallCount}`);

    res.json({
      userInfo,           // Embed user info here
      user: username,
      summary: {
        totalRepos: repos.length,
        publicRepos: originals.length,
        totalLanguages: Object.keys(allLangs).length
      },
      topRepos: detailed,
      languageStats: allLangs,
      activity: patterns,
      insights,
      generatedAt: new Date().toISOString(),
      stats: {
        githubApiCalls: apiCallCount,
        analysisTimeSeconds: duration
      }
    });
  } catch (err) {
    console.error(`‚ùå Error: ${err.message}`);
    res.status(500).json({ error: 'Failed to analyze user.', message: err.message });
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', time: new Date().toISOString() });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`üöÄ GitHub Analyzer running at http://localhost:${PORT}`);
});
